#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <inttypes.h>
#include <limits.h>
#include <iostream>
#include <iomanip>
#define BUFFER_LENGTH 65532               ///< The buffer length (crude but fine)
#define MAX_SIZE 65532
static char receive[BUFFER_LENGTH];     ///< The receive buffer from the LKM
static int ret, fd;
using namespace std;
// The class Config handle the driver configuration message (INIT)
class Config
{
public:
        Config() : sys_clock(0x5f5e100), freq_max(0x2faf080)
        {
                freq = 1; // 1 Hz
                nb_ech = 4; // 4*16 samples
                etat_trigger = 1; // RISING EDGE
                signal = 1; // BUTTON

        }
        //Handle user entry : might not be there in a better architecture
        void ch_freq()
        {
                bool wrong_value = true;
                while(wrong_value) {
                        cout << "Enter the integer frequency" << endl;
                        uint32_t value;
                        cin>>value;
                        wrong_value = !set_freq(value);
                        if(wrong_value) {
                                cin_flush();
                                cout << "Wrong frequency"<<endl;
                        }
                }
        }
        void ch_nb_ech()
        {
                bool wrong_value = true;
                while(wrong_value) {
                        cout << "Enter the number of sample you want" << endl;
                        uint32_t value;
                        cin>>value;
                        wrong_value = !set_nb_ech(value);
                        if(wrong_value) {
                                cin_flush();
                                cout << "Wrong sample count"<<endl;
                        }
                }
        }
        void ch_signal()
        {
                bool wrong_value = true;
                while(wrong_value) {
                        cout << "Enter the signal input method" << endl;
                        cout << " 1 : BUTTON" << endl;
                        cout << " 2 : PMOD" << endl;
                        uint32_t value;
                        cin>>value;
                        wrong_value = !set_signal(value);
                        if(wrong_value) {
                                cin_flush();
                                cout << "Wrong input method"<<endl;
                        }
                }
        }
        void ch_etat_trigger()
        {
                bool wrong_value = true;
                while(wrong_value) {
                        cout << "Enter the trigger edge" << endl;
                        cout << " 0 : falling edge" << endl;
                        cout << " 1 : rising edge" << endl;
                        uint32_t value;
                        cin>>value;
                        wrong_value = !set_etat_trigger(value);
                        if(wrong_value) {
                                cin_flush();
                                cout << "Wrong edge type"<<endl;
                        }
                }
        }
        //Getters / Setters, with check
        bool set_freq(uint32_t freq)
        {
                if(freq == 0 || freq > freq_max) {
                        return false;
                }
                this->freq = sys_clock/(sys_clock/freq); 
                return true;
        }
        uint32_t get_freq()
        {
                return freq;
        }
        bool set_nb_ech(uint32_t nb_ech)
        {
                if(nb_ech == 0) {
                        return false;
                }
                if(nb_ech % 16 == 0) {
                        this->nb_ech = nb_ech / 16;
                } else {
                        this->nb_ech = nb_ech / 16 + 1;
                }
                // We should check the size here
                return true;
        }
        uint32_t get_nb_ech()
        {
                return nb_ech;
        }
        bool set_signal(uint32_t signal)
        {
                if(signal != 1 && signal != 2) {
                        return false;
                }
                this->signal = signal;
                return true;
        }
        uint32_t get_signal()
        {
                return signal;
        }
        bool set_etat_trigger(uint32_t etat_trigger)
        {
                if(etat_trigger != 0 && etat_trigger != 1) {
                        return false;
                }
                this->etat_trigger = etat_trigger;
                return true;
        }
        uint32_t get_etat_trigger()
        {
                return etat_trigger;
        }
        // Generate the message
        // Warning ! binary values, could be some 0
        void craft_init(char* buffer) {
                strcpy(buffer,"INIT \0");
                uint_to_buff(buffer + 5, nb_ech);
                uint_to_buff(buffer + 9, signal);
                uint_to_buff(buffer + 13, etat_trigger);
                uint_to_buff(buffer + 17, (sys_clock / freq)); 
                buffer[21] = 0;
        }

private:
        void cin_flush()
        {
                cin.clear();
                cin.ignore();
        }
        void uint_to_buff(char* buffer,uint32_t val)
        {
                uint8_t i;
                for(i = 0; i < 4; i++) {
                        buffer[i] = (val >> (24 - i*8)) & 0xFF;
                }
        }
        const uint32_t sys_clock;
        const uint32_t freq_max;
        uint32_t freq;
        uint32_t nb_ech;
        uint32_t signal;
        uint32_t etat_trigger;

};
void check_fsm_status()
{
        ret = write(fd, "STATUS", 6); // Send the string to the LKM
        if (ret < 0){                                                           
                perror("Failed to write the message to the device.");           
                exit(errno);         
        }
        ret = read(fd, receive, BUFFER_LENGTH);        // Read the response from the LKM
        if (ret < 0){                                                           
                perror("Failed to read the message from the device.");          
                exit(errno);                                                   
        }
        printf("Status is %s\n",receive);
        usleep(100000);
}
void send_then_check_cmd(const char* cmd, uint32_t size)
{
        ret = write(fd, cmd, size); // Send the string to the LKM
        if (ret < 0){
                perror("Failed to write the message to the device.");
                exit(errno);
        }
        ret = read(fd, receive, BUFFER_LENGTH);        // Read the response from the LKM
        if (ret < 0){                                                           
                perror("Failed to read the message from the device.");          
                exit(errno);                                                   
        }                                                                       
        usleep(100000);
}
static uint32_t to_uint32(char* number)                                         
{                                                                               
        uint32_t ret = 0;                                                       
        uint32_t i;                                                             
        for(i = 0; i < 4; i++) {                                                
                ret |= number[i] << (i*8);                                                 
        }                                                                       
        return ret;                                                             
}
int main(int argc, char* argv[]){
        
        // Gather the desired configuration
        Config config_init;
        config_init.ch_freq();
        config_init.ch_nb_ech();
        config_init.ch_signal();
        config_init.ch_etat_trigger();
        cout << "The sampler will be launched in a few time ..." << endl;
        // Open the device with read/write access
        fd = open("/dev/fpga_manip", O_RDWR);
        if (fd < 0){
                perror("Failed to open the device...");
                return errno;
        }
        char init[30];
        config_init.craft_init(init);
        // Print a resume
        cout << endl;
        cout << "***********************************" << endl;
        cout << "***********************************" << endl;
        cout << " Frequency  : " << dec << config_init.get_freq() << " Hz" << endl;
        cout << " Number of samples : " << dec << config_init.get_nb_ech() * 16 << endl;
        cout << " Signal type : " << dec << config_init.get_signal() << " (";
        if(config_init.get_signal() == 1) {
                cout<<"BUTTON)"<<endl;
        } else {
                cout<<"PMOD)"<<endl;
        }
        cout << " Edge : ";
        if(config_init.get_etat_trigger() == 1) {
                cout << " RISING" << endl;
        } else {
                cout << " FALLING" << endl;
        }
        cout << "***********************************" << endl;
        cout << "***********************************" << endl;
        //Begin the treatment, with debug messages
        check_fsm_status();
        send_then_check_cmd(init,21);
        check_fsm_status();
        send_then_check_cmd("LAUNCH",6);
        check_fsm_status();
        while(strcmp("YES",receive) && strcmp("ERR",receive)) {
                send_then_check_cmd("FINISHED",8);
        }
        //Check for an error in the sampler
        if(strcmp("ERR",receive) == 0) {
                cout << "An error occured : aborting." << endl;
                close(fd);
                return 1;
        }
        // Start to read the data
        ret = write(fd, "READ", 4); // Send the string to the LKM
        if (ret < 0){
                perror("Failed to write the message to the device.");           
                return errno;                                                   
        }
        printf("The data should be ready now\n"); 

        FILE* r_file = fopen ("/tmp/data.csv", "w");
        if (r_file < 0) {
                perror("Failed to open destination file");
                return errno;
        }

        fprintf(r_file,"%s;%s\n","Value","Iteration");
        uint32_t read_samples = 0;
        uint8_t unaligned_data = 0;
        while(read_samples < config_init.get_nb_ech()*16) {
                int i;
                ret = read(fd, receive, MAX_SIZE);
                if (ret < 0) {
                        perror("Failed to read data from the device\n");
                        fclose(r_file);
                        return errno; 
                }
                unaligned_data = ret%4;
                if(unaligned_data) {
                        perror("Data alignment issue\n");
                        fclose(r_file);
                        return -1;
                }
                for(i = 0; i < ret; i+=4) { // Alignment
                        uint32_t data = to_uint32(receive+i);
                        fprintf(r_file, "%d;%d\n" , data, i/4);
                        fprintf(r_file, "%d;%d\n" , data, i/4 + 1);
                        read_samples++;
                }
        }
        fclose(r_file);

        ret = write(fd, "t", 1); // Send the string to the LKM        
        if (ret < 0){                                                           
                perror("Failed to write the message to the device.");           
                return errno;                                                   
        }
        check_fsm_status();
        close(fd);
        return 0;
}
